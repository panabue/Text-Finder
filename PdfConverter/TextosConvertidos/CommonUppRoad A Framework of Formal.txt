CommonUppRoad: A Framework of Formal
Modelling, Verifying, Learning, and Visualisation
of Autonomous Vehicles
Rong Gu1, Kaige Tan2, Andreas Holck Høeg-Petersen3, Lei Feng2, and Kim
Guldstrand Larsen3
1 Mälardalen University, Sweden
rong.gu@mdu.se
2 KTH, Sweden
{kaiget, lfeng}@kth.se
3 Aalborg University, Denmark
{ahhp, kgl}@cs.aau.dk
Abstract. Combining machine learning and formal methods (FMs) pro-
vides a possible solution to overcome the safety issue of autonomous
driving (AD) vehicles. However, there are gaps to be bridged before this
combination becomes practically applicable and useful. In an attempt to
facilitate researchers in both FMs and AD areas, this paper proposes a
framework that combines two well-known tools, namely CommonRoad
and UPPAAL. On the one hand, CommonRoad can be enhanced by the
rigorous semantics of models in UPPAAL, which enables a systematic
and comprehensive understanding of the AD system’s behaviour and
thus strengthens the safety of the system. On the other hand, controllers
synthesised by UPPAAL can be visualised by CommonRoad in real-world
road networks, which facilitates AD vehicle designers greatly adopting
formal models in system design. In this framework, we provide auto-
matic model conversions between CommonRoad and UPPAAL. There-
fore, users only need to program in Python and the framework takes care
of the formal models, learning, and verification in the backend. We per-
form experiments to demonstrate the applicability of our framework in
various AD scenarios, discuss the advantages of solving motion planning
in our framework, and show the scalability limit and possible solutions.
Keywords: Autonomous vehicles · Motion planning · UPPAAL · Com-
monRoad · Reinforcement learning.
1
Introduction
Autonomous Driving (AD) has seen a significant development in the automotive
industry in the past decade. The Society of Automotive Engineers (SAE) has
defined the six levels of AD [26]. Levels 0 - 2 are what we have in most of the mod-
ern vehicles nowadays. Level-3 AD means vehicles can detect the environment
and make informed decisions by themselves, but they still need human drivers to
arXiv:2408.01093v1  [cs.MA]  2 Aug 2024
2
Rong Gu et al.
stay alert and take control at any moment, whereas Level-4 AD vehicles do not
require human interaction in most circumstances, however, humans still have
the option to manually override in case of emergencies. The highest AD level is
five, where vehicles do not require human attention at all. The current technolo-
gies can only achieve level-3 AD or level-4 AD in conceptual vehicular models.
One of the biggest challenges is the safety issue. Different from the casualties
caused by human-driven cars, the public can hardly accept even one accident
caused by an AD vehicle [4][24]. Automotive companies are running road tests
for their AD vehicles over millions of miles a year, and yet accidents still keep
occurring [34]. Therefore, to increase the public’s confidence in AD, road-based
or even simulation-based testing of AD vehicles is not enough.
Formal methods (FMs) are well-known for providing rigorous analysis of
safety-critical systems. In recent years, a great amount of research has been car-
ried out on the application of FMs in overcoming all sorts of safety issues of AD
[14][27][33]. However, the usability and scalability of FMs when being adopted
in AD systems are still challenging. First, as mathematics-based methods, FMs
need a steep learning curve for AD researchers and practitioners. Moreover, the
lack of tools like Matlab in the FMs community, which provide off-the-shelf
blocks for users to reuse, means of visualization, and conversion between models
and executable code, is a significant drawback. These disadvantages hinder users
outside the FMs community from applying formal methods in their domains.
Second, when considering complex scenarios of AD, such as intersections with a
large number of human-driven vehicles and complex traffic rules, FMs often fall
short of scalability [12]. Third, AD vehicles often involve machine-learning-based
components, such as controllers that are trained by reinforcement learning (RL)
[29]. These components often require a huge amount of data for training and
validation, and their control logic is different from traditional software, which
makes the verification of such components extremely difficult.
In this paper, we propose a combination of tools from both communities
of FMs and AD, namely UPPAAL [17] and CommonRoad [2], which would
improve the usability of FMs in AD development and enhance the safety aspect
of AD. CommonRoad1 is an open-source toolset for AD development, testing,
and visualization. CommonRoad contains scenarios of AD, vehicle dynamics
models, and vehicle parameters. Scenarios in CommonRoad can be designed
manually in their GUI or converted from existing databases (e.g., highD [16]).
It also provides almost 4,000 scenarios converted from real-world driving scenes.
CommonRoad is written in Python and it supports various motion planners
based on search and learning. Although CommonRoad has a drivability checker,
it has no support from FMs and thus does not provide safety guarantees on the
motion-planning results.
UPPAAL, as a state-of-the-art model checker, has added functions for RL in
its recent release2. It supports modelling timed games, in which the behaviours
of two players are formally described by timed (or hybrid) automata, which
1commonroad.in.tum.de
2UPPAAL 5 on uppaal.org
Modelling, Verifying, Learning, and Visualisation of Autonomous Vehicles
3
is a formalism for modelling real-time systems. Therefore, we can model the
real-time behaviours of AD and other vehicles, even describe their dynamics
by ordinary differential equations (ODE), in timed games, and perform RL for
motion planning in UPPAAL. Moreover, although this approach uses ODE and
hybrid automata, it still keeps the possibility of exhaustive verification, which
returns absolute true/false answers of safety. However, UPPAAL does not have
motion-plan visualisation, and the construction of timed games is very difficult
for those who are not familiar with the formalism and tool.
In this paper, we propose a framework that combines CommonRoad and
UPPAAL, namely CommonUppRoad, in which we provide an automatic model
conversion between UPPAAL and CommonRoad. Specifically, we convert the
network of roads, static obstacles, and planning goals in CommonRoad into con-
stant variables of timed games in UPPAAL. As constant variables, they do not
occupy the state space of the formal model, which benefits the scalability greatly.
Further, we develop functions for collision and off-road detection in timed games.
These functions consider the shapes of vehicles, such as their widths, lengths,
and orientations. We also define the templates of timed games, which model
the vehicle dynamics and the atomic actions for controlling the AD vehicles.
With the conversion of scenarios and our predefined timed games, one can start
synthesising an AD controller in UPPAAL with little extra effort.
One of the benefits of using UPPAAL for controller synthesis is that it sup-
ports search-based [5] and learning-based methods [9]. Using the search-based
method, one can synthesise a so-called permissive controller, which is guaranteed
to be safe, i.e., collision-free and always on the road. Next, one can optimise the
permissive controller by RL, e.g., a fast controller reaching the goal within a time
frame. Safety is ensured in the learning results as the state-action space has been
restricted by the permissive controller, which excludes unsafe state-action pairs.
The safe and permissive controller is similar to the concept of a safety shield to
RL [1], but it does not need the manual exclusion of unsafe actions. We provide
methods to transform UPPAAL strategies into 1) decision trees [28], which can
be directly used in the Python code of CommonRoad, or 2) a set of trajectories
injected back to the scenario files in CommonRoad. This model conversion al-
lows us to visualise UPPAAL strategies in real-world scenarios, thus facilitating
the usability of learning and formal verification in UPPAAL. In a nutshell, the
contributions of our paper are as follows.
– An automatic model conversion between CommonRoad and UPPAAL, in-
cluding CommonRoad scenarios to UPPAAL models, and UPPAAL strate-
gies to controllers or trajectories in CommonRoad.
– Vehicle dynamics described by timed-game templates associated with ODEs.
The templates allow both search-based and learning-based controller synthe-
sis, as well as exhaustive and statistical model checking.
– An experimental analysis of the usability and scalability of motion planning
in UPPAAL. The planning is based on UPPAAL models converted from
CommonRoad and uses both search-based and learning-based methods.
4
Rong Gu et al.
The remainder of the paper is organised as follows. Section 2 introduces the
background knowledge for understanding this paper. Section 3 describes the
problem and an example of AD motion planning. Section 4 is about model
conversion between CommonRoad and UPPAAL before Section 5 introduces the
two motion planning methods in UPPAAL. Section 6 describes the experiments,
results, and a discussion about the strengths and weaknesses of the current
methods. Section 7 presents the related work in both AD and FMs communities.
Section 8 concludes the paper and introduces future work.
2
Preliminaries
In this section, we introduce the preliminaries for understanding this paper as
well as the mathematical notions. We first describe the formalism of verifica-
tion, learning in UPPAAL, and the definition of decision trees that we use for
representing strategies in UPPAAL. Next, we briefly introduce concepts of Com-
monRoad, which are used in this paper.
2.1
UPPAAL, Timed Games, and Decision Trees
UPPAAL is a state-of-the-art model-checking tool for real-time systems [17].
A UPPAAL model is defined as a network of Timed Automata (TA). A TA
consists of finite sets of locations, edges and real-valued non-negative variables
called clocks which progress at the rate of one. Locations can be labelled with
invariants over clocks, which must be true for the process to stay in that location.
A location can also be marked as either ‘Urgent’ or ‘Committed’, which in both
cases means that no time is allowed to pass while the process is in this location
and with the additional requirement for the latter that the next transition must
follow one of the outgoing edges from the committed location.
Transitions between locations can be guarded by clocks so as to ensure certain
conditions are met before a transition can happen. When a transition occurs an
update operation can affect the system state, for example by resetting some of
the clocks. Further, we can define broadcast channels on edges such that when
the model transitions via such an edge, a signal is sent to a set of listening edges
which will trigger transitions via these edges simultaneously.
Transitions between locations can be interpreted as actions, and in a timed
game (TG) [5], we distinguish between controllable and uncontrollable actions,
which in UPPAAL are represented by solid and dashed edges respectively. The
first actions are controlled by an agent playing intentionally in order to accom-
plish some objectives. Uncontrollable actions either happen stochastically or are
invoked by a purposefully antagonistic environment (the ‘other’ player).
In a control setting, the agent must learn a winning strategy that can deal
with a possibly antagonistic environment. A strategy can either involve adhering
to specified safety requirements (for example, ‘never enter location x if clock c
is less than 0.9’) or optimizing for some objective function (for example, ‘get
to location y as fast as possible’). UPPAAL uses symbolic techniques to solve
Modelling, Verifying, Learning, and Visualisation of Autonomous Vehicles
5
the first type of game and derives a strategy that provides a set of ‘safe’ actions
for a given state of the system. For the second type of game, UPPAAL has
a reinforcement learning (RL) engine [9] that via an online refinement scheme
partitions the state space according to the expected cost of performing each
action, mimicking classical Q-learning techniques. Furthermore, UPPAAL can
learn the strategy for (near) optimal control while being subjugated to the safety
strategy, thereby ensuring that only safe actions are considered.
As an example of a TG, consider the case where an agent has to move a
certain distance d within some time limit τ while spending as little energy as
possible. The agent has access to two actions, move fast (afast) or move slow
(aslow). Moving fast is efficient in terms of covering distance, but more expensive
in terms of energy. On the other hand, the precise distance travelled by each
action is not fully known to the agent, as the environment can affect this in some
way. For example, afast might move the agent a distance somewhere between 0.4
and 0.6 and likewise for aslow. The agent must devise a strategy that generally
moves slowly (to preserve energy) but also avoids ending up in situations where
it cannot be certain to reach d within τ even if only choosing afast from then on.
The UPPAAL tool allows us to use symbolic model checking to synthesize
a strategy that both satisfies the safety requirement (i.e., move a distance of d
before τ time has passed) and maximises the optimization objective (i.e., spend
as little energy as possible).
The result is a decision-tree-like structure for each action, where every branch
node is an axis-aligned split in one of the state dimensions. Each leaf node
corresponds to a region of the state space and contains the estimated Q-value of
performing that given action in this specific region. Given a concrete state s, the
optimal action can then be chosen by consulting every action-specific decision
tree and choosing the action whose tree yielded the largest Q-value for s.
2.2
CommonRoad
CommonRoad is an open-source framework designed to facilitate the devel-
opment, evaluation, and benchmarking of motion planning algorithms for au-
tonomous vehicles [2]. It offers a comprehensive suite of tools and datasets,
including realistic traffic scenarios, dynamic and static obstacles, and a wide
range of environmental conditions. The platform supports modularity, enabling
the integration of vehicle models, optimization techniques, and sensor data pro-
cessing methods. CommonRoad is particularly valuable for simulating complex
driving environments and evaluating the safety and efficiency of different motion
planning strategies. It enables rigorous testing under diverse conditions, ensuring
autonomous driving systems can effectively tackle real-world challenges.
3
Problem Description
In this section, we define the problem and introduce a running example that we
use for illustration throughout the paper.
6
Rong Gu et al.
3.1
Research Questions
Our motivation for this paper is to bridge the gap between the research areas
of formal methods (FMs) and autonomous driving (AD). Safety is one of the
dominating factors that AD vehicles concern. However, AD techniques, such as
machine learning, often fall short of safety guarantees and thus are not recom-
mended by most industrial standards. FMs are well-known for providing safety
guarantees for safety-critical systems. Still, the fact that using FMs requires a
deep understanding of the underlying mathematical notions and methods makes
the usability of FMs questionable. In this paper, we propose a combination of
two well-known tools in both areas, namely UPPAAL and CommonRoad, which
we believe would greatly benefit the development of AD vehicles and the evo-
lution of FMs. First, the abundant scenarios in CommonRoad provide a set of
benchmarks for evaluating the usability and scalability of FMs in the AD area,
especially when integrating RL and model checking in the design of AD vehicles.
Second, the visualization of scenarios and vehicle trajectories in CommonRoad
can facilitate the development of FMs-based motion-planning algorithms. Last,
FMs in UPPAAL can strengthen CommonRoad in the safety aspect of AD vehi-
cle development and improve AD designers’ understanding of the system because
of the rigorous syntax and semantics that formal models provide. To know if the
combination of UPPAAL and CommonRoad can indeed achieve the expected
scientific improvement, we design three research questions and answer them in
the remainder of this paper.
– RQ1: How can scenarios in CommonRoad be converted to UPPAAL models?
– RQ2: How can strategies in UPPAAL be represented as controllers in Com-
monRoad to control AD vehicles in the corresponding scenarios?
– RQ3: What is the limit of UPPAAL in solving the planning problems in
CommonRoad?
The answer to RQ1 would tell us if it is possible to automatically transform
a scenario in CommonRoad, including a network of roads, static and dynamic
obstacles, and a planning problem, into a UPPAAL model that is syntactically
and semantically correct, and how to achieve it. The answer to RQ2 would give
us a solution to visualise strategies in UPPAAL in a dynamic scenario. These two
answers would greatly motivate AD designers to adopt FMs in system design and
verification. Since we want to utilise the search-based method in UPPAAL to
synthesise absolutely safe AD controllers, scalability would be an issue. Thanks
to our previous study that integrates RL and model checking in UPPAAL [14],
the scalability can be improved to an extent. However, the limit of UPPAAL
when solving the planning problems in CommonRoad is still unknown, so we
aim to answer it in RQ3.
3.2
Example
In this section, we introduce an example of scenarios in CommonRoad (see Fig.
1). This example serves to illustrate the transformation of entities between UP-
PAAL and CommonRoad in Section 4. Fig. 1(a) depicts the scenario, where
Modelling, Verifying, Learning, and Visualisation of Autonomous Vehicles
7
(a) A scenario in CommonRoad
(b) Structure of the scenario
Fig. 1. Running example.
an AD vehicle is travelling at an intersection and targets to turn left safely. In
this scenario, multiple lanes are separated by solid or dashed lines, representing
different traffic restrictions, and other vehicles can be reactive or move along a
predefined trajectory. Fig. 1(b) shows the structure of the scenario XML file. As
seen, the structure contains information for motion planning of the AD vehicle.
CommonRoad provides methods to parse the XML file and edit the scenario in
Python. Our goal of model conversion is two-fold.
(i) Convert a scenario to a UPPAAL model for motion planning.
(ii) Convert a strategy synthesised by UPPAAL into either a decision tree in
Python or a moving entity with a predefined trajectory in the scenario.
4
Model Conversion
In this section, we describe our methods for model conversion between Common-
Road and UPPAAL. First, we generally describe the model conversion and the
UPPAAL templates instantiated with the information converted from Common-
Road. Next, we introduce the methods of converting scenarios in CommonRoad
to UPPAAL models and strategies in UPPAAL to entities in CommonRoad.
4.1
General Description
Fig. 2 generally depicts model conversion. The conversion from CommonRoad
to UPPAAL can be split into two categories: i) behavioural models of the AD
vehicles and moving obstacles are converted to instances of TG templates, and
ii) static models of the road network (a.k.a. lanelet), static obstacles, and the
planning goal are converted to struct variables in the C-like code of UPPAAL.
8
Rong Gu et al.
Fig. 2. Overall description of model conversion. Blue boxes are entities in Common-
Road. Green boxes are entities in UPPAAL.
After running motion-planning in UPPAAL, we get strategies for winning the
timed games. These strategies can be converted to two models in CommonRoad:
i) a decision-tree controller in Python, and ii) a trajectory in the scenario XML
file. The latter can be directly visualised in CommonRoad and checked for col-
lision and offroad by the drivability checker of CommonRoad [23], whereas the
former can be used as a reactive controller telling the AD vehicle what to do in
different situations. Next, we introduce the model conversion in detail.
4.2
CommonRoad to UPPAAL
Static models: road network, obstacles, and goal. In CommonRoad, the
scenarios are outlined in an XML file which includes a formal depiction of the
road network, both static and dynamic obstacles, and the planning problem of
the AD vehicle(s). Fig. 1(b) provides an overview of the XML files’ structure to
describe a scenario. To be specific, the road network is composed of lanelets [6],
which are the fundamental units and serve as interconnected and drivable road
segments. A lanelet’s definition encompasses its left and right bounds, with each
bound depicted by an array of points forming a polyline. In addition, obstacles in
CommonRoad contain static and dynamic obstacles, and they are characterised
by their types (e.g., car, bicycle, and pedestrian) and shapes (e.g., rectangle
and circle). The dynamic obstacles are also described with temporal movements
in the scenario, which can be known behaviour with defined state sequence
trajectory, unknown behaviour with occupancy sets, and unknown stochastic
behaviour with probability distributions. Furthermore, each AD vehicle has a
planning problem, and it is characterised by an initial state and goal region.
Modelling, Verifying, Learning, and Visualisation of Autonomous Vehicles
9
Our work facilitates the automated transformation of CommonRoad scenario
XML files into C-like code compatible with UPPAAL model simulations. For
each scenario, we parse the XML file to extract detailed information on lanelets,
obstacles, and planning problems. As shown in the green boxes in Fig. 2, we
construct C-like declarations and data structures for lane boundaries, lane at-
tributes, obstacle descriptions, planning problems, etc. By inserting these gen-
erated code blocks into appropriate sections of the template, we produce output
XML files that seamlessly integrate CommonRoad scenario data into the exe-
cutable UPPAAL model, thus enabling rigorous simulation and verification of
driving scenarios.
Drivability check: Collision and offroad detection To enable a safe con-
troller design in UPPAAL, we define the constraint on the motion planer that
is guaranteed to never go off the road and collide with obstacles. Two functions,
namely offroad() and collide(), are introduced to check the status of the AD
vehicle and assess if the safety requirement is fulfilled.
The offroad() function evaluates whether a vehicle’s state, represented as
a rectangle or a polygon, remains within the confines of individual lanes of
the lane network of a traffic scenario. Based on the geometric and kinematic
relationship, the function estimates the vehicular corner points and uses them to
recursively check if they are within the occupancy of a single lane, thus assessing
the potential boundary violation of the lane network.
Meanwhile, the collide() function checks the relationship between the AD
vehicle and the other obstacles by calculating the shortest distance between two
occupancy sets represented by convex polygons. The distance is calculated by
circle approximation [18], where we approximate the polygonal shape of the
vehicle with a series of circles, and then compute the minimum distance between
the centres of two sets of approximation circles. Given a predefined distance as
the safety margin between vehicles, the minimal distance between the AD vehicle
and other obstacles must fulfill this requirement, otherwise a collision happens.
Behaviour models: vehicle dynamics. Vehicle dynamics and controllable
actions of the AD vehicle are modelled as timed games and ordinary differen-
tial equations (ODE) in UPPAAL. Additionally, the actions of perception and
controlling are synchronised. Note that the synchronisation is not mandatory,
as perception and controlling as well as the actions of the AD vehicle and other
vehicles can be asynchronous. Fig. 3 depicts the sketch of UPPAAL models.
Model CM (Fig. 3(a)) is the concurrent module for action synchronisation.
It is the only timed game that deals with time, i.e., via the clock variable t.
Time elapses at location L3 for exactly period time units, and it is followed by
transitions between urgent locations, e.g., L1 and L2, meaning that actions occur
instantaneously at the end of every period. Model VD (Fig. 3(b)) is a hybrid
automaton describing the vehicle dynamics with ODE. The model also has two
discrete transitions: one for perception, i.e., sampling the continuous variables,
and one for moving obstacle reaction. Although we include a hybrid automaton
10
Rong Gu et al.
Fig. 3. UPPAAL Models
in our UPPAAL model, we can still use the symbolic model checker and search-
based synthesis as long as the continuous variables are hybrid clocks, which are
only used in ODE. Note that the AD vehicle dynamics is also modelled as a
hybrid automaton similar to Fig. 3(b) but without the discrete transition of
moving obstacles (blue box). Model AA (Fig. 3(c)) is a timed game with con-
trollable transitions (aka, actions). It is synchronised with model CM via channel
ego, meaning that the motion planner gets to choose from one of the actions in
AA every period time units. The model also has uncontrollable transitions, that
is, the self-loops at locations. These transitions represent the actions of percep-
tion. Although they are performed by the AD vehicle, they do not need to be
considered by the motion planner because perception happens deterministically.
One may argue that perception may have errors that happen stochastically or
arbitrarily. UPPAAL supports modelling such errors. However, motion planners
do not need to choose among them because errors are not controllable by the
AD vehicles. In fact, the ability to model stochastic and arbitrary errors is one
of the advantages of running motion planning in UPPAAL. We can even switch
the semantics of errors in our UPPAAL model to enable more efficient learning
than classic algorithms. Due to the page limit, we leave this to future work.
4.3
UPPAAL to CommonRoad
Exporting UPPAAL strategies A strategy in UPPAAL that its RL engine
synthesises is represented as a set of decision trees over the state space. Each
tree represents the Q-function for a specific action and maps a (continuous)
state to the Q-value of taking the corresponding action in that state. We call
this representation of a strategy a ‘QTree’. Such a strategy can be exported to
a JSON format via the saveStrategy query, and we provide a Python program
that can import and convert the strategy to a Python object allowing for direct
interaction with CommonRoad.
Our Python program provides two classes: QTree and DecisionTree. The
first is a direct adaptation of the structure of ‘QTree’-strategies from UPPAAL
Modelling, Verifying, Learning, and Visualisation of Autonomous Vehicles
11
and acts as the entry point when loading a strategy. The latter is a classical
(binary) decision tree with actions in its leaves. Both classes adhere to API of
stable-baselines3 [25], which is the default framework for most popular RL
tools, such as Gymnasium [30] and, relevant to this work, commonroad-rl [31].
Most importantly, they expose a function called predict(s) which takes a state
s and returns the optimal action according to the strategy.
From a QTree object, one can generate a DecisionTree by calling the mem-
ber function to_decision_tree() on the QTree object. The conversion happens
according to a novel algorithm, that starts by sorting the leaves of all action-
specific trees in the ‘QTree’-strategy in descending order of their Q-value. Each
leaf defines a region in the state space, and since the first leaf in the aforemen-
tioned sorting has the best Q-value of all, the region defined by this leaf must
be assigned the action of the tree that the leaf stemmed from. Thus, we create
a shallow tree with a branch node for each upper and lower bound that makes
up the leaf region. For a k-dimensional state space, we need 2k branch nodes to
perfectly capture a bounded region. Each additional leaf is added (in the sorted
order) by following the path from the root node, adding new branch nodes if
needed to capture the region of the leaf to be added, and discarding the addition
if the leaf region is already perfectly covered by previous leaves (as these will
have had a better Q-value).
The result is a decision tree that perfectly captures the strategy learned by
UPPAAL. This allows us to return to CommonRoad after having synthesised
a strategy in UPPAAL and directly interact with the tool using our safe and
near-optimal control strategy. One obvious use case for this is interfacing with
the RL tools provided in commonroad-rl, where a scenario can be executed as an
RL environment. At each execution step, we obtain a state of the environment
that we pass to the predict(s) method to get an appropriate action from the
controller, which is then passed back into the environment that executes the
next step. Likewise, the strategy would also be possible to use to solve motion
planner problems and driveability checks.
Simulating trajectories with UPPAAL A simpler approach than directly
using the trained strategy in a CommonRoad scenario is to sample states from
the strategy and show them as a trajectory in the scenario. Given the conversion
from a CommonRoad scenario to a UPPAAL model, we can use the simulate
command in UPPAAL to sample states from the execution of the model.
We store the sampled points in a log file, where concrete values of the state
variables are recorded. As a default, we simply need to output the values of the
five variables that determine the AD vehicle’s states (coordinates on the x and
y axes, orientation, velocity and acceleration) and then we add these sampled
points as a trajectory of the AD vehicle to the scenario that the model was con-
verted from. However, the user might want to add custom dynamic obstacles or
special state variables in the UPPAAL model which were not part of the original
scenario. Our code supports this and only requires that the extra information is
added to the query file of the UPPAAL model and that the relevant constants
12
Rong Gu et al.
in the Python code of model conversion are updated appropriately (e.g., update
the constant of moving obstacle numbers if more are added).
We implement this process as a Python script, which provides a seamless
method for visualizing the behaviour of the AD vehicle under the control of a
synthesised strategy as GIF animations.
5
Motion Planning in UPPAAL
In this section, we introduce our motion-planning methods in UPPAAL. Gen-
erally, we have two classes of synthesis methods: one uses symbolic exhaustive
searching and one uses RL. The former is implemented in UPPAAL Tiga [5] and
the latter is in UPPAAL Stratego [9]. However, in UPPAAL 5, these two meth-
ods are integrated. One can synthesise a safe motion plan by using the searching
method first and then optimise the safe motion plan via learning. The learning
algorithm can be an existing function in UPPAAL, such as Q-learning [32], or
a user-defined function linked to UPPAAL as an external library [14]. Next, we
introduce these two classes of synthesis in detail.
5.1
Search-based Synthesis
As the name indicates, search-based synthesis is about searching all actions at
each of the reachable states and finding out the traces of state-action pairs that
fulfil the requirement. As timed games have continuous variables (i.e., clocks),
their state spaces are infinite and uncountable. Thanks to the symbolic model
checker of UPPAAL, we can obtain an equivalent but discrete representation of
the continuous state space, which makes the exhaustive search possible. Since
the search is exhaustive, the search-based synthesis is sound and complete, that
is, when a correct motion plan exists, UPPAAL must find it (completeness),
and when UPPAAL finds a motion plan, it must be correct (soundness). Now
that we have the model converted from CommonRoad, we can synthesise a safe
motion plan that is guaranteed to never go off the road and never collide with
obstacles. The query for synthesis is as follows, where functions collide() and
offroad() are defined in Section 4.2 and provided as predefined functions in
our TG templates that users of CommonUppRoad can easily reuse3.
strategy safe = control: A[] !collide() && !offroad()
(1)
Since the search-based synthesis is complete, if UPPAAL returns unsatisfied,
it means the state space does not have any safe path. If Query (1) returns a
strategy, it is permissive as it contains all the safe state-action pairs, including
the inefficient ones. For example, when an AD vehicle needs to turn left at an
intersection (Fig. 1), an efficient and safe strategy is to wait until the intersection
is empty and then turn. However, a permissive strategy would allow the AD
vehicle to wait unnecessarily long, e.g., till the end of the motion-planning time
3More detail about the CommonUppRoad: sites.google.com/view/commonupproad
Modelling, Verifying, Learning, and Visualisation of Autonomous Vehicles
13
frame, and then turn, or even go straight forward and then turn back. Obviously,
permissive strategies need to be optimised. However, they provide safety shields
for RL, which gives us optimal strategies.
5.2
Learning-based Synthesis
Learning-based synthesis does not need to exhaustively search the entire state
space. Instead, it randomly simulates the model and samples traces of state-
action pairs. Note that the sampled state-action pairs are not symbolic any-
more, as the state-space exploration now is a random simulation. Therefore,
learning-based synthesis is not sound or complete. We need methods to provide
safety guarantees on the learning results. Previously, we have proposed a post-
verification on the learning results [14]. One can use this method by running
the following queries, where MAXT is the maximum time of one learning episode,
reward is the formula representing the reward function of RL, and goal() is a
function returning true when the AD vehicle reaches the goal.
strategy reach = maxE(reward)[<=MAXT]: <> goal()
(2)
A[] !collide() && !offroad() under reach
(3)
A<> goal() under reach
(4)
Query (2) returns a strategy that may reach the destination. The reachability
and safety of strategy reach are not guaranteed as learning is based on random
simulation. Hence, we use Queries (3) and (4) to verify the strategy reach.
The former checks if the AD vehicle never collides and never goes off the road
under the control of strategy reach. The latter checks if the AD vehicle always
eventually reaches the goal regardless of other vehicles’ actions.
Learning-based synthesis can be combined with search-based synthesis by
using the following query, where safe is a strategy synthesised by Query (1).
Hence, Query (1) must be executed prior to running this query.
strategy reachS = maxE(reward)[<=MAXT]: <> goal() under safe
(5)
The random simulation of Query (5) is restricted to the state-action pairs in-
cluded in the permissive strategy safe. Hence, the simulation would never reach
unsafe states and thus Query (3) is not needed. Strategy safe performs as a
safety shield of the learning process. Similar to Query (2), although Query (5)
explicitly specifies the learning objective is to reach the goal states, reachS is not
guaranteed to be goal-reaching, because learning has no correctness guarantee.
For example, the learning episodes can be not enough to cover all the branches
that the state space has, or the reward function is problematic. In addition,
the time for running Query (1), the precondition of running Query (5), can be
extremely long as it requires an exhaustive state space exploration. However,
when the AD actions for the motion planner to choose are not too many but the
distance of travelling is long, learning-based methods may perform worse than
the search-based methods. We have evaluated and reported the strengths and
weaknesses of both methods in multi-agent planning [13].
14
Rong Gu et al.
Fig. 4. Scenarios for the experiments.
6
Experiments
We have conducted two groups of experiments to show the usability and scala-
bility of CommonUppRoad, respectively. We run the experiments on an M2-chip
Macbook Pro with 16 GB memory. In the following sections, we introduce the
design of the experiments and the results3.
6.1
Experiment Design
Experiment I (usability): We select ten representative scenarios in Common-
Road (Fig. 4), from simple ones to complex ones, and convert them to UPPAAL
models by using a Python program implementing the method in Section 4.2. To
tame the sizes of the models, we define the maximum time to be ten, meaning
that the models are forced to reset to the initial state when the execution time
turns ten. This restriction of execution time would limit the model sizes within
a reasonable scale. We further evaluate the scalability in Experiment II, where
the model sizes can be much larger. We check the syntax of the generated UP-
PAAL models, proving the syntactic correctness of the generated models. Then,
we verify the following query in UPPAAL. If the query returns true, the model
exists a trace where the AD vehicle never collides or goes off the road.
E[] !collide() && !offroad()
(6)
Last, we run Queries (1) and (5) to generate safe motion plans. Note that since
the execution time is limited, the starting points of the AD vehicles are set
to be close to the goals such that they are reachable within the time limit.
However, Experiment I is about showing the usability of CommonUppRoad,
which is supported by the experiment result already.
Modelling, Verifying, Learning, and Visualisation of Autonomous Vehicles
15
Table 1. Results of Experiment I
Scenario Syntax
Query (6)
Query (1)
Query (5)
SAT Time (ms) SAT Time (ms) SAT Time (ms)
1
3,186
28,928
24,628
2
65
2,264
5,090
3
4
315
1,337
4
111
3,473
8,132
5
333
142
13,842
6
335
14,364
21,796
7
179
12,024
12,667
8
127
55
6,523
9
124
54
6,444
10
359
154
15,362
Experiment II (scalability): We select scenario 2 in Fig. 4 and modify it
in this experiment. We change the maximum time steps for a learning episode
and the distance from the starting point to the goal area accordingly. We run
Queries (1) and (5) to show how scalable the search-based method is. Then, we
run Query (2) and verify the resulting strategies against Queries (3) and (4) to
show the correctness of the learning-based method.
6.2
Experiment Results
Table 1 shows the result of Experiment I. All the converted UPPAAL models
pass the syntax check, which shows the static information of scenarios can be
successfully transferred to variable declarations in UPPAAL. Further, the results
of queries are all satisfied (
) meaning that the UPPAAL model can generate
safe and reachable motion plans. In general, the computation times of all scenar-
ios are reasonable (less than 30 seconds) because we set the goals to be close to
the starting points. Note that the two moving obstacles are near the AD vehicle
in Scenario 1 but are far from the AD vehicle in other scenarios when the latter
approaches the goal. Therefore, the computation of the Query (1) is the longest
in Scenario 1 , which also indicates the largest safe strategy. Consequently, the
computation time of the other two queries is also the longest in Scenario 1 . The
result of Experiment I indicates the possibility of compositional motion planning
in complex scenarios where scalability becomes an issue.
Fig. 5. Experiment II Result
Figure 5 shows the trends of computation
times for different kinds of motion plans. As
expected, the time for computing safe mo-
tion plans (i.e., safe) increases exponentially
as they are synthesised by the search-based
method. However, the time for optimising the
safe plans (i.e., reachSafe), increases linearly
as the synthesis method is learning and the
state space is restricted by the safe plans al-
ready. The motion plans that are synthesised
16
Rong Gu et al.
purely by learning (i.e., reach) do not have safety and reachability guarantees.
Therefore, we verify the learning results against Queries (3) and (4). When the
verification returns false, we increase the learning episodes and learn again until
the results satisfy those queries. Figure 5 shows the computation time for the final
round of learning whose verification results are true. Although the computation
times of the learning-based method are shorter than those of the search-based
method, it involves a trial-and-error process, that is, repetitive learning when
verification fails. If we count this time in, the entire synthesis time can be even
longer than the time of the search-based method. However, when the model state
space becomes too big to be handled by the search-based method, learning is a
good solution. The animated visualisation of UPPAAL-synthesised motion plans
is posted online3.
6.3
Discussion
We answer the research questions in Section 3 based on the experiment results.
Answer to RQ1: Scenarios in CommonRoad can be converted to con-
stant variables defined in the timed-game templates in UPPAAL. Com-
monRoad functions of collision-detection and offroad-detection can be
converted to the C-like functions in UPPAAL.
Although the correctness of model conversion has been shown in the ex-
periments, there is room for improvement. For example, offroad detection in
UPPAAL is done over the entire road network, which is not always necessary
and influences efficiency.
Answer to RQ2: UPPAAL strategies can be converted to decision-tree
controllers in CommonRoad, or sampled points of trajectories that are
visualised in CommonRoad.
In the experiments, we have demonstrated the visualisation of possible tra-
jectories that a decision-tree controller can have. However, there is no complete-
ness guarantee on the sampled trajectory points, because sampling is via random
simulations. As our timed-game templates preserve the ability of exhaustive ver-
ification, one way of collecting all the possible trajectories of a decision-tree
controller is to use liveness properties in UPPAAL. Specifically, during the ver-
ification of Query (4), we can label the state-action pairs visited by the model
checker and sample concrete states in the labelled symbolic states. This process
is similar to our strategy compression proposed previously [14]. However, due to
the page limit, we leave this as future work.
Modelling, Verifying, Learning, and Visualisation of Autonomous Vehicles
17
Answer to RQ3: The search-based method can generate safe motion plans
and be used as safety shields for learning. However, its computation time
increases exponentially as the time step of the AD vehicle increases lin-
early. In contrast, the computation time of the learning-based method
increases linearly. However, the learning results do not have a safety guar-
antee. Post-verification of the learning results would overcome this limit,
but it involves a trial-and-error process, which can be time-consuming.
As we reported previously [13], one shall adaptively employ the search-based
and learning-based methods according to their applications. Compositional mo-
tion planning can be a good solution for the scalability issue. However, it involves
extra effort such as contract-based concatenation. We leave this for future work.
7
Related Work
To ensure the reliability and safety of autonomous driving (AD) systems, formal
methods (FMs) are widely applied for the verification and validation of mo-
tion planning algorithms. Researchers use formal specifications to define safety
properties and other constraints that the planning algorithms must satisfy [21].
Specifically, CommonRoad has been used as a platform for applying FMs,
such as temporal logic, to solve various aspects of motion-planning problems.
Lercher et al. [19] use linear temporal logic specification for the reachability anal-
ysis to overapproximate the reachable set of an AD vehicle and validate the im-
plementation in the CommonRoad platform. Liu et al. [20] address specification-
compliant motion planning for AD vehicles based on set-based reachability anal-
ysis with automata-based model checking. The effectiveness of the methods is
demonstrated with scenarios from the CommonRoad benchmark suite. Hekmat-
nejad et al. [15] translate Responsibility-Sensitive-Safety (RSS) rules into Signal
Temporal Logic (STL) formulas and utilise the STL formulas to monitor off-
line naturalistic driving data provided with CommonRoad. In comparison, our
framework provides a bi-directional model conversion between CommonRoad
and UPPAAL. In addition, CommonUppRoad has two ways of motion plan-
ning, i.e., search-based and learning-based, and the corresponding verification
methods. These features make our framework comprehensive and greatly bene-
fit control engineers unfamiliar with FMs.
In the FMs community, researchers have studied ways to facilitate system
engineers to apply FMs in AD systems. Gu et al. [11] develop a tool-supported
methodology for AD vehicle mission planning, namely MALTA, in which UP-
PAAL is employed as a task scheduler at the backend of the tool. Besides UP-
PAAL, there are many other tools that can potentially solve the AD motion-
planning problem, e.g., Kronos [8], LTSim [7], and SpaceEx [10]. These tools
mainly suffer from a common problem: state-space explosion. Compositional
planning has the potential to overcome the state-space explosion as it can split
the entire problem into smaller but compositional sub-problems [3][22]. Our ex-
periment shows the ability of CommonUppRoad to be used in compositional
18
Rong Gu et al.
planning. The well-defined structure of scenarios provides the foundation for
composing contracts for concatenating motion plans of sub-problems.
8
Conclusion and Future Work
We propose a framework called CommonUppRoad that combines CommonRoad
and UPPAAL. The framework provides automatic model conversion between
CommonRoad and UPPAAL, which would greatly benefit control engineers to
adopt formal methods in their system design, analysis, and verification. We
also offer timed-game (TG) templates to describe the vehicle dynamics and C-
like functions of collision- and offroad-detection. These features would facilitate
learning algorithm designers to use formal methods, that is, TG as the modelling
language, and (statistical) model checking as the verification technique, in the
domain of AD vehicles. We report the performance of search-based and learning-
based synthesis in various scenarios. The search-based method can generate safe
motion plans but scales badly when the model becomes large and complex. The
learning-based method scales better, but it does not have a safety guarantee.
Post-verification can compensate for this shortcoming, but it involves a trial-
and-error process to obtain the final safety-guaranteed result. One of the future
works is to investigate compositional motion planning, which would overcome
the state-space explosion profoundly. Another direction is to use model checking
in UPPAAL to interpret AD scenarios (aka, operational design domain (ODD))
and generate critical scenarios that are highly likely to cause collisions. This
scenario generation and selection method would greatly benefit the industry in
AD testing, verification, and validation.
References
1. Alshiekh, M., Bloem, R., Ehlers, R., Könighofer, B., Niekum, S., Topcu, U.: Safe
reinforcement learning via shielding. In: Proceedings of the AAAI conference on
artificial intelligence. vol. 32 (2018)
2. Althoff, M., Koschi, M., Manzinger, S.: Commonroad: Composable benchmarks for
motion planning on roads. In: 2017 IEEE Intelligent Vehicles Symposium (IV). pp.
719–726. IEEE (2017)
3. Alur, R., Moarref, S., Topcu, U.: Compositional and symbolic synthesis of reactive
controllers for multi-agent systems. Information and Computation 261, 616–633
(2018)
4. BBC: Uber’s self-driving operator charged over fatal crash. https://www.bbc.com/
news/technology-54175359 (September 16th, 2020)
5. Behrmann, G., Cougnard, A., David, A., Fleury, E., Larsen, K.G., Lime, D.:
Uppaal-tiga: Timed games for everyone. In: Nordic Workshop on Programming
Theory (NWPT’06) (2006)
6. Bender, P., Ziegler, J., Stiller, C.: Lanelets: Efficient map representation for au-
tonomous driving. In: 2014 IEEE Intelligent Vehicles Symposium Proceedings. pp.
420–425 (2014). https://doi.org/10.1109/IVS.2014.6856487
7. Blom, S., van de Pol, J., Weber, M.: Ltsmin: Distributed and symbolic reachability.
In: International Conference on Computer Aided Verification. Springer (2010)
Modelling, Verifying, Learning, and Visualisation of Autonomous Vehicles
19
8. Bozga, M., Daws, C., Maler, O., Olivero, A., Tripakis, S., Yovine, S.: Kronos: A
model-checking tool for real-time systems. In: International Symposium on Formal
Techniques in Real-Time and Fault-Tolerant Systems. Springer (1998)
9. David, A., Jensen, P.G., Larsen, K.G., Mikučionis, M., Taankvist, J.H.: Uppaal
stratego. In: TACAS 2015. pp. 206–211. Springer (2015)
10. Frehse, G., Le Guernic, C., Donzé, A., Cotton, S., Ray, R., Lebeltel, O., Ripado, R.,
Girard, A., Dang, T., Maler, O.: Spaceex: Scalable verification of hybrid systems.
In: International Conference on Computer Aided Verification. Springer (2011)
11. Gu, R., Baranov, E., Ameri, A., Seceleanu, C., Enoiu, E.P., Cürüklü, B., Legay, A.,
Lundqvist, K.: Synthesis and verification of mission plans for multiple autonomous
agents under complex road conditions. ACM Trans. Softw. Eng. Methodol. (jun
2024). https://doi.org/10.1145/3672445
12. Gu, R., Enoiu, E., Seceleanu, C.: Tamaa: Uppaal-based mission planning for au-
tonomous agents. In: Proceedings of the 35th Annual ACM Symposium on Applied
Computing. pp. 1624–1633 (2020)
13. Gu, R., Jensen, P.G., Poulsen, D.B., Seceleanu, C., Enoiu, E., Lundqvist, K.: Ver-
ifiable strategy synthesis for multiple autonomous agents: a scalable approach.
International Journal on Software Tools for Technology Transfer 24(3), 395–414
(2022)
14. Gu, R., Jensen, P.G., Seceleanu, C., Enoiu, E., Lundqvist, K.: Correctness-
guaranteed strategy synthesis and compression for multi-agent autonomous sys-
tems. Science of Computer Programming 224, 102894 (2022)
15. Hekmatnejad, M., Yaghoubi, S., Dokhanchi, A., Amor, H.B., Shrivastava, A.,
Karam, L., Fainekos, G.: Encoding and monitoring responsibility sensitive safety
rules for automated vehicles in signal temporal logic. In: Proceedings of the 17th
ACM-IEEE International Conference on Formal Methods and Models for System
Design. pp. 1–11 (2019)
16. Krajewski, R., Bock, J., Kloeker, L., Eckstein, L.: The highd dataset: A drone
dataset of naturalistic vehicle trajectories on german highways for validation of
highly automated driving systems. In: 2018 21st International Conference on Intel-
ligent Transportation Systems (ITSC). pp. 2118–2125 (2018). https://doi.org/
10.1109/ITSC.2018.8569552
17. Larsen, K.G., Pettersson, P., Yi, W.: Uppaal in a nutshell. International journal
on software tools for technology transfer 1, 134–152 (1997)
18. Lenz, D., Kessler, T., Knoll, A.: Stochastic model predictive controller with chance
constraints for comfortable and safe driving behavior of autonomous vehicles. In:
2015 IEEE Intelligent Vehicles Symposium (IV). pp. 292–297 (2015). https://
doi.org/10.1109/IVS.2015.7225701
19. Lercher, F., Althoff, M.: Specification-compliant reachability analysis for au-
tonomous vehicles using on-the-fly model checking (2024)
20. Liu, I., Althoff, M.: Specification-compliant driving corridors for motion planning
of automated vehicles. IEEE Transactions on Intelligent Vehicles (2023)
21. Mehdipour, N., Althoff, M., Tebbens, R.D., Belta, C.: Formal methods to comply
with rules of the road in autonomous driving: State of the art and grand challenges.
Automatica 152, 110692 (2023)
22. Muhammad, N., Rong, G., Cristina, S., Kim, G.L., Brian, N., Michele, A.: Energy-
optimized motion planning for autonomous vehicles using uppaal stratego. In: The
18th International Symposium on Theoretical Aspects of Software Engineering.
Springer (2024)
20
Rong Gu et al.
23. Pek, C., Rusinov, V., Manzinger, S., Üste, M.C., Althoff, M.: Commonroad driv-
ability checker: Simplifying the development and validation of motion planning
algorithms. In: 2020 IEEE intelligent vehicles symposium (IV). pp. 1013–1020.
IEEE (2020)
24. Post,
T.W.:
17
fatalities,
736
crashes:
The
shocking
toll
of
tesla’s
autopilot.
https://www.washingtonpost.com/technology/2023/06/10/
tesla-autopilot-crashes-elon-musk/ (June 10th, 2023)
25. Raffin, A., Hill, A., Gleave, A., Kanervisto, A., Ernestus, M., Dormann, N.: Stable-
baselines3: Reliable reinforcement learning implementations. Journal of Machine
Learning Research 22(268), 1–8 (2021), http://jmlr.org/papers/v22/20-1364.
html
26. SAE: Taxonomy and definitions for terms related to driving automation systems
for on-road motor vehicles (April, 2021)
27. Sánchez, J.M.G., Nyberg, T., Pek, C., Tumova, J., Törngren, M.: Foresee the
unseen: Sequential reasoning about hidden obstacles for safe driving. In: 2022 IEEE
Intelligent Vehicles Symposium (IV). pp. 255–264. IEEE (2022)
28. Schilling, C., Lukina, A., Demirović, E., Larsen, K.: Safety verification of decision-
tree policies in continuous time. Advances in Neural Information Processing Sys-
tems 36 (2024)
29. Sutton, R.S., Barto, A.G., et al.: Reinforcement learning. Journal of Cognitive
Neuroscience 11(1), 126–134 (1999)
30. Towers, M., Terry, J.K., Kwiatkowski, A., Balis, J.U., Cola, G.d., Deleu, T., Goulão,
M., Kallinteris, A., KG, A., Krimmel, M., Perez-Vicente, R., Pierré, A., Schulhoff,
S., Tai, J.J., Shen, A.T.J., Younis, O.G.: Gymnasium (Mar 2023). https://doi.
org/10.5281/zenodo.8127026, https://zenodo.org/record/8127025
31. Wang, X., Krasowski, H., Althoff, M.: Commonroad-rl: A configurable reinforce-
ment learning environment for motion planning of autonomous vehicles. In: IEEE
International Conference on Intelligent Transportation Systems (ITSC) (2021).
https://doi.org/10.1109/ITSC48978.2021.9564898
32. Watkins, C.J., Dayan, P.: Q-learning. Machine learning 8, 279–292 (1992)
33. Yang, Q., Simão, T.D., Jansen, N., Tindemans, S.H., Spaan, M.T.: Reinforcement
learning by guided safe exploration. arXiv preprint arXiv:2307.14316 (2023)
34. Zhang, X., Tao, J., Tan, K., Törngren, M., Sanchez, J.M.G., Ramli, M.R., Tao,
X., Gyllenhammar, M., Wotawa, F., Mohan, N., et al.: Finding critical scenarios
for automated driving systems: A systematic mapping study. IEEE Transactions
on Software Engineering 49(3), 991–1026 (2022)
